# UDP/TCP socket 통신 - server/client 간 통신 프로그램 

## Socket이란?
: 소켓이란, 네트워크 상에서 통신하는 응용 프로그램 간의 연결을 담당하고 응용 계층의 프로세스와 end-to-end 전송 계층 사이의 인터페이스 역할을 한다. 따라서 응용 계층에    있는 응용 프로그램들이 특정 소켓을 통하여 4계층으로 데이터를 송신하면 OSI 나머지 계층을 거쳐, 수신 측의 4계층에서 그 소켓을 통해 통신하고자 하는 응용 프로그램으로 데    이터를 보내 수신하게 된다. 이러한 소켓 통신에서 필요한 것은 통신 방식인 프로토콜과 목적지 주소인 ip와 Port 번호이다. 보통 인터넷 소켓을 사용하며 4계층에서 동작하게    되므로 이때 사용하는 프로토콜은 UDP/TCP 방식이며 ip주소는 수신측을 식별해주고, port번호는 통신해야 할 프로세스를 식별해준다.따라서 어떠한 방식으로, 특정 수신측의 어    떠한 프로세스에 데이터를 보낼 지 결정해야 소켓 통신이 가능하다. 
따라서 이러한 server-client간 통신이 가능하도록 프로그램을 구현하는 것이 소켓 프로그래밍이며 본 프로젝트에서는 소켓 프로그래밍의 원리를 이해하면서 클라이언트가 보낸 데이터를 수정하여 서버에서 보내주고, 클라이언트에서 데이터를 받아 출력하는 간단한 프로그램을 구현한다.
 
## Socket의 시스템콜
: 소켓의 시스템 콜이란, 소켓 생성,바인딩,연결,대기,허용,읽기,쓰기,끊음 등과 같은 소켓 동작을 위한 호출 형식, 라이브러리 함수이다. 파이썬에서는 socket 라이브러리를 임포트하여 내장 함수들을 사용할 수 있다.

#### socket.socket(family, socket type)
: 소켓 객체를 생성하는 함수. family란 사용하는 네트워크 주소의 체계 (AF_INET:IPv4/AF_INET6:IPv6), type은 소켓의 type(datagram/stream)를 나타낸다. 
#### bind()
: 서버가 클라이언트의 요청이 오는 것을 기다릴 때 소켓을 생성한 후 지정한 포트에 연결하는 함수. "객체명.bind(HOST,PORT)"형식으로 호출하며 호출 시 호스트 이름과 포트 넘버를 튜플로 감싸서 전달한다.
### listen()
: 서버에서 클라이언트가 바인딩된 포트로 연결을 할 때까지 기다리는 함수이다. 인자에는 최대로 요청을 받을 클라이언트의 수가 들어오며 클라이언트로부터 연결 요청이 들어오면 리턴하게 되는데, 따라서 이 코드의 다음 행에는 해당 연결을 받아들이기 위한 accecpt() 메소드를 호출하는 부분이 주로 오게 된다.
#### connect()
: 클라이언트가 서버와 통신하는 방법에서 한 가지 차이점이 있다면 클라이언트는 바인드나 리스닝의 과정이 필요없다는 것이다. 클라이언트는 능동적으로 서버에 연결하며, 연결된 소켓으로 항상 1:1로 서버와 통신하기 때문이다. (물론 이것은 클라이언트의 입장이고 결국 서버가 바인딩이 필요한 이유는 '같은 포트'로 여러 클라이언트와 동시에 접속될 수 있기 때문이다.) 연결은 객체명.connect()를 사용하며 이 때 사용하는 인자는 bind()와 동일하다. 이 메소드는 연결이 수립되면 리턴하며, 이때 리턴값은 존재하지 않는다. 따라서 클라이언트는 최초 생성한 소켓을 통신에 사용하면 된다.

#### accept()
: (소켓, 주소정보)로 구성되는 튜플을 리턴한다. 이때의 소켓은 처음에 생성한 소켓과는 '별개의' 객체로 클라이언트와 연결이 구성되어 실제로 데이터를 주고 받을 수 있는 창구가 된다. 이 소켓은 연결이 들어와서 listen(), accept() 가 호출될 때마다 생성될 수 있기 때문에 만약, 연결이 구성된 소켓을 멀티스레드로 처리한다면 1:N의 연결도 처리할 수 있다.
#### recv(), sendall()
: 데이터를 주고받는 함수. "객체.함수()"형식으로 사용하며 데이터를 읽어들이는 함수 recv()를 사용할 때는 안에 읽어들일 최대 크기를 바이트로 명시해야 한다. 
#### close()
: 생성한 연결을 해제하는 함수. 연결이 종료되면 소켓을 꼭 닫아줘야 하고, 이미 닫힌 소켓에서 연결을 시도할 경우 에러가 발생한다.

## UDP/TCP socket 통신의 차이
#### datagram, UDP
: 데이터그램 소켓의 연결은 단방향이고 신뢰할 수 없다. 또한 수신 측에서 데이터를 순서대로 받는다고 보장할 수도 없다. 데이터그램은 L4 계층에서 사용자 데이터그램 프로토콜(UDP : User Datagram Protocol)이라는 표준 프로토콜을 사용한다. 안전장치도 별로 없어서 단순하고 간단하고, 가벼운 방법이므로 부하가 매우 적다. 하지만 패킷이 잘 도착했는지 확인하려면 수신 측에서 승인 패킷(Acknowledgment Packet)을 보내줘야한다. 패킷 손실이 허용되기도 한다. 보통, 네트워크 게임이나 미디어 스트리밍에서 자주 쓰인다.
 
#### stream, TCP
: 스트림 소켓 연결은 전화와 같이 '믿을 수 있는 양방향 통신'을 제공한다. 한쪽에서 다른 한쪽으로의 연결을 초기화하고, 연결이 생성된 후에는 어느 쪽에서든 다른 쪽으로 통신할 수 있다. 보낸 내용이 실제로 도착했는지도 즉각 확인할 수 있다. 스트림 소켓은 전송 제어 프로토콜(TCP : Transmission Control Protocol)이라 불리는 표준 통신 프로토콜을 사용한다. TCP는 OSI 모델에서 L4(Transport Layer)에 있다. 컴퓨터 네트워크에서 데이터는 보통 패킷이라는 단위로 전송되는데, TCP는 패킷이 오류 없이 순서대로 도착하도록 설계되었다. 웹서버, 메일서버, 각 클라이언트 애플리케이션 모두는 TCP와 스트림 소켓을 사용한다. 


#### 통신 방식의 차이
: 앞서도 언급했듯 UDP 통신은 datagram 소켓을 사용하며 handshaking 단계가 없고 sender가 ip와 port를 패킷에 지정하여 보내면 receiver는 패킷에서 그 ip와 port를 보고 데이터를 수신하므로 데이터에 신뢰성이 없고 순서로 정렬되어 있지 않을 수 있다. 따라서 데이터가 손실될 수도 있다. 
 반면 TCP 통신에서는 stream 소켓을 사용하여 클라이언트와 서버 간 '연결'이 존재하여 서버가 실행 중일 때 클라이언트가 요청을 보내면 서버가 수락하여 연결이 생성된다. 서버에서 tcp 소켓을 생성할 때 ip, port를 지정하고 클라이언트에서 연결을 위한 소켓을 생성하면 해당 서버로 연결을 시도한다. handshaking 단계를 거치고 순서대로 전달되므로 신뢰성있는 통신을 제공한다.  
 
 

 
 
 참고자료
 https://on1ystar.github.io/socket%20programming/2021/03/16/socket-1/
 http://www.ktword.co.kr/test/view/view.php?m_temp1=5829
 https://soooprmx.com/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%86%8C%EC%BC%93-%EC%97%B0%EA%B2%B0-%EC%82%AC%EC%9A%A9%EB%B2%95/